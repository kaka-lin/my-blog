<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MySQL on Kaka's Blog</title><link>https://kaka-lin.github.io/my-blog/tags/mysql/</link><description>Recent content in MySQL on Kaka's Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 10 Jun 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://kaka-lin.github.io/my-blog/tags/mysql/index.xml" rel="self" type="application/rss+xml"/><item><title>[LeetCode] 226 Invert Binary Tree</title><link>https://kaka-lin.github.io/my-blog/2020/06/226_invert_binary_tree/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/226_invert_binary_tree/</guid><description>226. Invert Binary Tree Discription Invert a binary tree.
Example: Input:
4 / \ 2 7 / \ / \ 1 3 6 9 Output:
4 / \ 7 2 / \ / \ 9 6 3 1 Solution 1: Recursion Runtime: 24 ms (87.55%) Memory Usage: 12.7 MB (100%) # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.</description></item><item><title>[LeetCode] 234 Palindrome Linked List</title><link>https://kaka-lin.github.io/my-blog/2020/06/234_palindrome_linked_list/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/234_palindrome_linked_list/</guid><description>234. Palindrome Linked List Discription Given a singly linked list, determine if it is a palindrome.
Example: Input: 1-&amp;gt;2 Output: false Input: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 Output: true Follow up: Could you do it in O(n) time and O(1) space?
Solution: Find the middle of the linked list. Reverse the second half of the linked list. Compare. Runtime: 76 ms (84.86%) Memory Usage: 23.6 MB (92.34%) # Definition for singly-linked list.</description></item><item><title>[LeetCode] 236 Lowest Common Ancestor Of A Binary Tree</title><link>https://kaka-lin.github.io/my-blog/2020/06/236_lowest_common_ancestor_of_a_binary_tree/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/236_lowest_common_ancestor_of_a_binary_tree/</guid><description>236. Lowest Common Ancestor of a Binary Tree Discription Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the definition of LCA on Wikipedia: â€œThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).</description></item><item><title>[LeetCode] 240 Search A 2d Matrix Ii</title><link>https://kaka-lin.github.io/my-blog/2020/06/240_search_a_2d_matrix_ii/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/240_search_a_2d_matrix_ii/</guid><description>240. Search a 2D Matrix II Discription Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example: Consider the following matrix:
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] Given target = 5, return true.</description></item><item><title>[LeetCode] 242 Valid Anagram</title><link>https://kaka-lin.github.io/my-blog/2020/06/242_valid_anagram/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/242_valid_anagram/</guid><description>242. Valid Anagram Discription Given two strings s and t , write a function to determine if t is an anagram of s.
Example: Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; Output: true Input: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot; Output: false Solution: Hash Table Runtime: 48 ms (84.31%) Memory Usage: 13.5 MB class Solution: def isAnagram(self, s: str, t: str) -&amp;gt; bool: if len(s) != len(t): return False length = len(s) table = {} for i in range(length): if s[i] in table: table[s[i]] += 1 else: table[s[i]] = 1 if t[i] in table: table[t[i]] -= 1 else: table[t[i]] = -1 for key, val in table.</description></item><item><title>[LeetCode] 297 Serialize And Deserialize Binar Tree</title><link>https://kaka-lin.github.io/my-blog/2020/06/297_serialize_and_deserialize_binar_tree/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/297_serialize_and_deserialize_binar_tree/</guid><description>297. Serialize and Deserialize Binary Tree Discription Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work.</description></item><item><title>[LeetCode] 344 Reverse String</title><link>https://kaka-lin.github.io/my-blog/2020/06/344_reverse_string/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/344_reverse_string/</guid><description>344. Reverse String Discription Write a function that reverses a string. The input string is given as an array of characters char[].
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
You may assume all the characters consist of printable ascii characters.
Example 1: Input: [&amp;quot;h&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;o&amp;quot;] Output: [&amp;quot;o&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;h&amp;quot;] Example 2: Input: [&amp;quot;H&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;h&amp;quot;] Output: [&amp;quot;h&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;H&amp;quot;] Solution 1: Two Pointers Runtime: 212 ms (70.</description></item><item><title>[LeetCode] 371 Sum Of Two Integers</title><link>https://kaka-lin.github.io/my-blog/2020/06/371_sum_of_two_integers/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/371_sum_of_two_integers/</guid><description>371. Sum of Two Integers Discription Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Example: Input: a = 1, b = 2 Output: 3 Input: a = -2, b = 3 Output: 1 Solution 1: Bit manipulation Ref: https://www.youtube.com/watch?v=qq64FrA2UXQ Explain key point 2 -&amp;gt; 10 3 -&amp;gt; 11 explain with 1 + 3: 11 =&amp;gt; this is</description></item><item><title>[LeetCode] 394 Decode String</title><link>https://kaka-lin.github.io/my-blog/2020/06/394_decode_string/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/394_decode_string/</guid><description>394. Decode String Discription Given an encoded string, return its decoded string.
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.
You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.
Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k.</description></item><item><title>[LeetCode] 509 Fibonacci Number</title><link>https://kaka-lin.github.io/my-blog/2020/06/509_fibonacci_number/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/509_fibonacci_number/</guid><description>509. Fibonacci Number Discription Example 1: Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: Input: 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. Solution: Top-Down Runtime: 24 ms (95.55%) Memory Usage: 12.7 MB (100%) class Solution: def fib(self, N: int) -&amp;gt; int: if N &amp;lt;= 1: return N cache = {0: 0, 1: 1} for i in range(2, N+1): cache[i] = cache[i-1] + cache[i-2] return cache[N] Time complexity O(N) Space complexity O(N)</description></item><item><title>[LeetCode] 542 01 Matrix</title><link>https://kaka-lin.github.io/my-blog/2020/06/542_01_matrix/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/542_01_matrix/</guid><description>542. 01 Matrix Discription Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.
The distance between two adjacent cells is 1.
Example 1: Input: [[0,0,0], [0,1,0], [0,0,0]] Output: [[0,0,0], [0,1,0], [0,0,0]] Example 2: Input: [[0,0,0], [0,1,0], [1,1,1]] Output: [[0,0,0], [0,1,0], [1,2,1]] Solution: Runtime: 656 ms (82.67%) Memory Usage: 14.7 MB (100%) class Solution: def updateMatrix(self, matrix: List[List[int]]) -&amp;gt; List[List[int]]: m, n = len(matrix), len(matrix[0]) for i in range(m): for j in range(n): if matrix[i][j] == 1: d = self.</description></item><item><title>[LeetCode] 557 Reverse Words In A String Iii</title><link>https://kaka-lin.github.io/my-blog/2020/06/557_reverse_words_in_a_string_iii/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/557_reverse_words_in_a_string_iii/</guid><description>557. Reverse Words in a String III Discription Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.
Example: Input: &amp;quot;Let's take LeetCode contest&amp;quot; Output: &amp;quot;s'teL ekat edoCteeL tsetnoc&amp;quot; Note: In the string, each word is separated by single space and there will not be any extra space in the string.
Solution 1: Runtime: ms (%) Memory Usage: MB (%) class Solution: def reverseWords(self, s: str) -&amp;gt; str: ans = &amp;quot;&amp;quot; for sub_s in s.</description></item><item><title>[LeetCode] 617 Merge Two Binary Trees</title><link>https://kaka-lin.github.io/my-blog/2020/06/617_merge_two_binary_trees/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/617_merge_two_binary_trees/</guid><description>617. Merge Two Binary Trees Discription Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.
You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</description></item><item><title>[LeetCode] 700 Search In A Binary Search Tree</title><link>https://kaka-lin.github.io/my-blog/2020/06/700_search_in_a_binary_search_tree/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/700_search_in_a_binary_search_tree/</guid><description>700. Search in a Binary Search Tree Discription Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node&amp;rsquo;s value equals the given value. Return the subtree rooted with that node. If such node doesn&amp;rsquo;t exist, you should return NULL.
Example: Given the tree: 4 / \ 2 7 / \ 1 3 And the value to search: 2 You should return this subtree:</description></item><item><title>[LeetCode] 733 Flood Fill</title><link>https://kaka-lin.github.io/my-blog/2020/06/733_flood_fill/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/733_flood_fill/</guid><description>733. Flood Fill Discription An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).
Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, &amp;ldquo;flood fill&amp;rdquo; the image.
To perform a &amp;ldquo;flood fill&amp;rdquo;, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.</description></item><item><title>[LeetCode] 841 Keys And Rooms</title><link>https://kaka-lin.github.io/my-blog/2020/06/841_keys_and_rooms/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/841_keys_and_rooms/</guid><description>841. Keys and Rooms Discription There are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room.
Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length. A key rooms[i][j] = v opens the room with number v.</description></item><item><title>[LeetCode] 876 Middle Of The Linked List</title><link>https://kaka-lin.github.io/my-blog/2020/06/876_middle_of_the_linked_list/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/876_middle_of_the_linked_list/</guid><description>876. Middle of the Linked List Discription Given a non-empty, singly linked list with head node head, return a middle node of linked list.
If there are two middle nodes, return the second middle node.
Note: The number of nodes in the given list will be between 1 and 100. Example: Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3. (The judge's serialization of this node is [3,4,5]).</description></item><item><title>[LeetCode] 905 Sort Array By Parity</title><link>https://kaka-lin.github.io/my-blog/2020/06/905_sort_array_by_parity/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/905_sort_array_by_parity/</guid><description>905. Sort Array By Parity Discription Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A.
You may return any answer array that satisfies this condition.
Example: Input: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Note: 1 &amp;lt;= A.length &amp;lt;= 5000 0 &amp;lt;= A[i] &amp;lt;= 5000 Solution 1: Two Pass Runtime: 76 ms (91.</description></item><item><title>[LeetCode] 912 Sort An Array</title><link>https://kaka-lin.github.io/my-blog/2020/06/912_sort_an_array/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/912_sort_an_array/</guid><description>912. Sort an Array Merge Sort Discription Given an array of integers nums, sort the array in ascending order.
Example: Input: nums = [5,2,3,1] Output: [1,2,3,5] Input: nums = [5,1,1,2,0,0] Output: [0,0,1,1,2,5] Constraints 1 &amp;lt;= nums.length &amp;lt;= 50000 -50000 &amp;lt;= nums[i] &amp;lt;= 50000 Solution 1: Merge Sort (Top-down Approach (Recursion)) Runtime: ms (%) Memory Usage: MB (%) class Solution: def sortArray(self, nums: List[int]) -&amp;gt; List[int]: if len(nums) &amp;lt;= 1: return nums mid = len(nums) // 2 left = self.</description></item><item><title>[LeetCode] 938 Range Sum Of Bs</title><link>https://kaka-lin.github.io/my-blog/2020/06/938_range_sum_of_bs/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2020/06/938_range_sum_of_bs/</guid><description>938. Range Sum of BST Discription Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive).
The binary search tree is guaranteed to have unique values.
Example: Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 Output: 32 Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 Output: 23 Solution: Depth First Search Runtime: 212 ms (93.</description></item></channel></rss>