<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Array on Kaka's Blog</title><link>https://kaka-lin.github.io/my-blog/tags/array/</link><description>Recent content in Array on Kaka's Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 04 Jul 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://kaka-lin.github.io/my-blog/tags/array/index.xml" rel="self" type="application/rss+xml"/><item><title>[DSA] Hash Table 介紹</title><link>https://kaka-lin.github.io/my-blog/2022/09/introduction/</link><pubDate>Fri, 16 Sep 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/09/introduction/</guid><description>Hash Table Hash Table 就是儲存 (key, value) 這種 mapping 關係的一種資料結構。 它是透過 Hash Function 來計算出 key 與 value 所對應的位置，如下所示: 前言 在 prority queue 裡，我們在乎的是資料的大小(優先度</description></item><item><title>[DSA] Binomial Heap 介紹</title><link>https://kaka-lin.github.io/my-blog/2022/09/binomial_heap/</link><pubDate>Mon, 12 Sep 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/09/binomial_heap/</guid><description>Binomial Heap 前言: 均攤 (Amortization) 介紹 在開始介紹 Binomial Heap 前，我們先來看看 Heap (Min Heap or Max Heap) 的 operation 時間複雜度: insert: O(log n) remove/delete: O(log n) 思考: 我們能不能減少 insert 的時間複雜度 -&amp;gt; O(1)，但一</description></item><item><title>[DSA] Heap Tree (堆積) 介紹</title><link>https://kaka-lin.github.io/my-blog/2022/09/heap_tree/</link><pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/09/heap_tree/</guid><description>Heap Tree 用 Tree 了解他，用 Array 實作相關的 operation 從 Binray Tree 的觀念出發，首先將原本 Tree 的 node 加上 Key (檢索鍵)，如下: key: priority or weights or others data: original data (like: todo) 有分: Min Heap(最小堆積)</description></item><item><title>[DSA] Binary Expression Tree 介紹</title><link>https://kaka-lin.github.io/my-blog/2022/09/expression_tree/</link><pubDate>Fri, 09 Sep 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/09/expression_tree/</guid><description>Binary Expression Tree Each internal node corresponds to the operator and each leaf node corresponds to the operand. Example: A expression tree for 3 * (5+7) would be: * / \ 3 + / \ 5 7 prefix: (* 3 (+ 5 7)) -&amp;gt; mul(3, plus(5, 7)) infix: 3 * (5+7) -&amp;gt; 四則運算 postfix: 3 5 7 + * -&amp;gt; 電腦上實際想要</description></item><item><title>[DSA] Binary Tree 介紹</title><link>https://kaka-lin.github.io/my-blog/2022/09/binary_tree/</link><pubDate>Fri, 09 Sep 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/09/binary_tree/</guid><description>Binary Tree (二元樹) 每個 node 最多就是只有 2 個 child node，且稱兩個 child node 為 left child 和 right child。 A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child.</description></item><item><title>[DSA] Introduction of Tree</title><link>https://kaka-lin.github.io/my-blog/2022/09/tree/</link><pubDate>Thu, 08 Sep 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/09/tree/</guid><description>Tree (樹) 樹就是Hierarchical Access，樹上的 node 沒有 child 數量限制，如下所示: Each node of the tree will have a root value and a list of references to other nodes which are called child nodes. 其他相關</description></item><item><title>[Object Detection] YOLO Image Preprocessing: resize or letterbox</title><link>https://kaka-lin.github.io/my-blog/2022/09/resize_image/</link><pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/09/resize_image/</guid><description>Resize image, Keeping Aspect Ratio or not 在 Train model 時，前處理常常會需要將 image resize 成 model input 的 size，如 YOLO 的 416x416, 608x608 等，這邊列舉幾種目前常見的 resize 方法，如下: Original image: Resized without keeping aspect ratio - cv::resize() [Square Inference] Resized with</description></item><item><title>[Tensorflow] Progress bar of custom training loop</title><link>https://kaka-lin.github.io/my-blog/2022/09/progress_bar/</link><pubDate>Fri, 02 Sep 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/09/progress_bar/</guid><description>Progress bar of Tensorflow 2&amp;rsquo;s custom training loop The collection of the progress bar methods for tf.GradientTape when training model 詳細 code 請看: progress_bar_tqdm.py progress_bar_keras.py progress_bar_click.py 1. tqdm 使用 tqdm 來顯示 model training 進度, loss and accuracy，如下: train_loss = tf.keras.metrics.Mean(name='train_loss') train_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(name='train_accuracy') for epoch in range(NUM_EPOCHS): n_batches = x_train.shape[0] /</description></item><item><title>[Tensorflow] Custom Training Loop</title><link>https://kaka-lin.github.io/my-blog/2022/09/custom_training_loop/</link><pubDate>Thu, 01 Sep 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/09/custom_training_loop/</guid><description>Custom Training Loop 在 tf.keras 中已經提供很方便的 training and evaluation loops, fit() 和 evaluate()。 但如果我們想要對 training 或 evaluation 進行更 low-level 的控制的話， 我們需要從頭開始寫自己的 training and evaluation loo</description></item><item><title>[Tensorflow] Introduction to tf.GradientTape and automatic differentiation</title><link>https://kaka-lin.github.io/my-blog/2022/08/introduction/</link><pubDate>Wed, 31 Aug 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/08/introduction/</guid><description>GradientTape 在介紹 tf.GradientTape 前我先來看看什麼是自動微分 (Automatic differentiation, AD) Automatic Differentiation 為了自動微分(Automatic differentiation)，TensorFlow 需要: 前</description></item><item><title>[PyTorch] Various Progress Bar in PyTorch</title><link>https://kaka-lin.github.io/my-blog/2022/08/progress_bar/</link><pubDate>Fri, 19 Aug 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/08/progress_bar/</guid><description>Pytorch Progress bar The collection of the progress bar methods for PyTorch when training model 詳細 code 請看: progress_bar_tqdm.py progress_bar_keras.py progress_bar_click.py 1. tqdm 使用 tqdm 來顯示 model training 進度, loss and accuracy，如下: for epoch in range(NUM_EPOCHS): n_batches = len(train_loader) print(f'Epoch {epoch+1}/{NUM_EPOCHS}') with tqdm(train_loader, total=n_batches, bar_format='{desc:&amp;lt;5.5}{percentage:3.0f}%|{bar:36}{r_bar}') as pbar: for idx, (x, y)</description></item><item><title>[PyTorch] Datasets &amp; DataLoaders</title><link>https://kaka-lin.github.io/my-blog/2022/08/datasets_dataloaders/</link><pubDate>Thu, 18 Aug 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/08/datasets_dataloaders/</guid><description>Datasets &amp;amp; DataLoaders PyTorch provides two data primitives (基本資料型態) that allow you to use pre-loaded datasets as well as your own data, as below: torch.utils.data.Dataset Stores the samples and their corresponding labels Dataset 定義資料的結構並且將其包起來，利如: 一張影像和一個標籤 一張影</description></item><item><title>[PyTorch] Tensors (張量)</title><link>https://kaka-lin.github.io/my-blog/2022/08/tensors/</link><pubDate>Wed, 17 Aug 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/08/tensors/</guid><description>Tensors Tensors are a specialized data structure that are very similar to arrays and matrices. In PyTorch, we use tensors to encode the inputs and outputs of a model, as well as the model’s parameters. 張量 (Tensor) 類似向量或矩陣，他是一個 n-維 (n-dimensional) 的資料型態，像是: 0</description></item><item><title>[Object Detection] 目標檢測評估指標 (Object Detection Metrics)</title><link>https://kaka-lin.github.io/my-blog/2022/08/object_detection/</link><pubDate>Tue, 16 Aug 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/08/object_detection/</guid><description>目標檢測評估指標 (Object Detection Metrics) Object Detection 需要執行兩個任務: decide whether an object exists in the scene: classification determine the position, the orientation and the shape of the object: localization 在現實場景中，一個場景會包含很多物件類別（如: 車輛、行</description></item><item><title>[Classification] 分類指標 (Classification Metrics)</title><link>https://kaka-lin.github.io/my-blog/2022/08/classification/</link><pubDate>Mon, 15 Aug 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/08/classification/</guid><description>分類指標 (Classification Metrics) Confuion Matrix (混淆矩陣) Predict Positive Predict Negative Actual Positive True Positive (TP) False Negative (FN) Actual Negative False Positive (FP) True Negative (TN) Recall and Precision Recall (召回率) Recall = TP / (TP + FN) 表示在所有正樣本中，能夠預測到多少個正樣</description></item><item><title>[DSA] Matrix Chain Multiplication | Dynamic Programming</title><link>https://kaka-lin.github.io/my-blog/2022/08/matrix_chain_multiplication/</link><pubDate>Sat, 13 Aug 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/08/matrix_chain_multiplication/</guid><description>Matrix Chain Multiplication Input: a sequence of n matries $(A_1, &amp;hellip;, A_n)$ Output: the product of $A_1A_2 &amp;hellip; A_n$ 根據 Associative (結合律) 可以將問題重新定義為: Matrix Chain Multiplication Problem 相關說明可參考: Observation Observation Each entry takes $q$ multiplications There are total $pr$ entries Time-Complexity: $\Theta(q)\Theta(pr) = \Theta(pqr)$ Associative (結合</description></item><item><title>[C++] Overloading(重載) &amp; Overriding (覆載) &amp; Plymorphism (多型)</title><link>https://kaka-lin.github.io/my-blog/2022/08/overloading_overriding_polymorphism.md/</link><pubDate>Fri, 12 Aug 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/08/overloading_overriding_polymorphism.md/</guid><description>Overloading(重載) &amp;amp; Overriding (覆載) &amp;amp; Plymorphism (多型) Smaple code 請參考: kaka-lin/Notes/C++/overloading_overriding_polymorphism/src/main.cc Overloading (重載、多載): 在一個類別 (class) 中，多個名稱相同，但參數不同的 Method (方法)。</description></item><item><title>[DSA] Longest Palindromic Substring | Dynamic Programming</title><link>https://kaka-lin.github.io/my-blog/2022/08/longest_palindromic_substring/</link><pubDate>Sun, 07 Aug 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/08/longest_palindromic_substring/</guid><description>Longest Palindromic Substring Leetcode: 5. Longest Palindromic Substring My solution: kaka-lin/leetcode/00005_longest-palindromic-substring The detail of explain of solution please see as below. 思路與解法說明請看下面。 Question Given a string s, return the longest palindromic substring in s Example 1: Input: s = &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Explanation: &amp;quot;aba&amp;quot; is also a valid answer. Example 2: Input: s = &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot; Constraints: 1</description></item><item><title>[DSA] KD Tree</title><link>https://kaka-lin.github.io/my-blog/2022/06/kdtree/</link><pubDate>Thu, 16 Jun 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/06/kdtree/</guid><description>K-D Tree KD Tree 又稱 K 維樹 (K-dimensional tree)，是一種可以對 K 維資料進行劃分的資料結構。可以看成二元搜尋樹的一種延伸，的對空間中的維度做劃分。主要應用於多維</description></item><item><title>[Docker] 容器與虛擬機</title><link>https://kaka-lin.github.io/my-blog/2022/06/docker_vs_vm/</link><pubDate>Thu, 09 Jun 2022 00:00:00 +0000</pubDate><guid>https://kaka-lin.github.io/my-blog/2022/06/docker_vs_vm/</guid><description>Docker - 容器 (Container) 與虛擬機 (VM) 簡單來說: 虛擬機 (Virtual Machine) 以作業系統為中心 容器 (Container) 以應用程式為中心 Container VM 應用程式為單位 作業系統為單位 依賴 Host OS 的 kernel 任意 Guest OS 封裝應用程</description></item></channel></rss>